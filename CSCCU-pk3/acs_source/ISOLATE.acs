#library "ISOLATE"
#include "zcommon.acs"
#include "8bdmlib.acs"

//int ServerMAX = 32;

//======| Area heal script distance falloff
Script 682 (int HealRadius, int HealRadiusMin, int HealAmount)
{
int PlayersTeam;
int Target_TID;
int TargetCount;
int FiringPlayer;
Bool OwnerOnly;
If(ActivatorTID() == 0)
	{
	FiringPlayer= ACS_ExecuteWithResult(257, 0); //Returns the target of the activator
	}
else
	{
	FiringPlayer=ActivatorTID();
	}

PlayersTeam = GetPlayerInfo(FiringPlayer-1000, PLAYERINFO_TEAM);

if (ACS_ExecuteWithResult(975, 1) == 0) {OwnerOnly = true;}

//==== Heal Allies	
int HealRate;
int HealTotal;
int Targ_Dist;
For(int q = 0;q < ServerMax; q++)
	{
	
	
	If(!PlayerInGame(q)){continue;}
	if(checkWeapon("RespawnCamera")&&GetActorProperty(0,APROP_HEALTH)>0){continue;}
	If(PlayersTeam != GetPlayerInfo(q, PLAYERINFO_TEAM)){continue;}
	If(OwnerOnly && (q+1000 != FiringPlayer)) {continue;}
	Target_TID = q+1000;
	Targ_Dist = xyzDistance(0,Target_TID);
	If((xyzDistance(0,Target_TID) < HealRadius) )
		{
		//now to calculate their healing based on how far they are from the source
		if (Targ_Dist <= HealRadiusMin){HealRate = 100;}
		else{HealRate = noneg(((((Targ_Dist- HealRadiusMin)*100)/HealRadius) - 100)*-1);}
		HealTotal = (HealAmount*HealRate)/100;
		//log(s:"Healed ",i:HealTotal);
		GiveActorInventory(Target_TID,"Health",HealTotal );
		GiveActorInventory(Target_TID,"AreaHealEffect",1 );
		}
	}
}

//Formerly 723
script "RadiusGiveSQ" (int GiveID, int GiveRadius, int GiveType)
{ 
int Target_TID;
int Target_Distance;
int FiringPlayer;
int PlayersTeam;
//int IsTeamGame = ACS_ExecuteWithResult(975, 1);
//if(GiveRadius == 0){terminate;}

// GiveType 1 = self + Friendlies
// GiveType 2 = Friendlies only
// GiveType 3 = Self only
// GiveType 4 = Enemies only
// GiveType 5 = self + Enemies
// GiveType 6 = All but self
// GiveType 7 = All
//if(GiveType << 1){GiveType = 1;}
//if(GiveType >> 7){GiveType = 7;}
If(ActivatorTID() <= 999)
	{
	FiringPlayer= ACS_ExecuteWithResult(257, 0); //Returns the target of the activator
	}
else
	{
	FiringPlayer=ActivatorTID();
	}
PlayersTeam = GetPlayerInfo(FiringPlayer-1000, PLAYERINFO_TEAM);
For(int i = 0;i < ServerMax; i++)
	{
	If(!PlayerInGame(i)){continue;}
	If(IsTeamGame)
		{
		switch(GiveType)
			{
			case 1:
			If(PlayersTeam != GetPlayerInfo(i, PLAYERINFO_TEAM)){continue;}
			Break;
			
			case 2:
			If(PlayersTeam != GetPlayerInfo(i, PLAYERINFO_TEAM) || (PlayersTeam == GetPlayerInfo(i, PLAYERINFO_TEAM) && i == FiringPlayer-1000)){continue;}
			Break;
			
			case 3:
			If(PlayersTeam != GetPlayerInfo(i, PLAYERINFO_TEAM) || (i != FiringPlayer-1000)){continue;}
			Break;

			case 4:
			If(PlayersTeam == GetPlayerInfo(i, PLAYERINFO_TEAM) || i == FiringPlayer-1000){continue;}
			Break;
			
			case 5:
			If(PlayersTeam == GetPlayerInfo(i, PLAYERINFO_TEAM) && i != FiringPlayer-1000){continue;}
			Break;
			
			case 6:
			If(i == FiringPlayer-1000){continue;}	
			Break;
			}
		}
	else
		{
		switch(GiveType)
			{
			case 1:
			If(i != FiringPlayer-1000){continue;}
			Break;
			
			case 2:
			If(i == FiringPlayer-1000 || i != FiringPlayer-1000){continue;}
			Break;
			
			case 3:
			If(i != FiringPlayer-1000){continue;}
			Break;
			
			case 4:
			If(i == FiringPlayer-1000){continue;}
			Break;
			
			Default:
			//If(i == FiringPlayer-1000 || i != FiringPlayer-1000){continue;}
			Break;
			}
		}
	Target_TID = i+1000;
	If(xyzDistance(0,Target_TID) < GiveRadius) // && FiringPlayer!=Target_TID
		{
		GiveActorInventory(Target_TID,"PackageID", GiveID);
		GiveActorInventory(Target_TID,"GivePackage", 1);
		}
	}
}

/*
function int xyzDistance (int tid1, int tid2)
{
	int x, y, z, d;
	x = GetActorX(tid1) - GetActorX(tid2) >> 16; // Convert fixed point to integer
	y = GetActorY(tid1) - GetActorY(tid2) >> 16;
	z = GetActorZ(tid1) - GetActorZ(tid2) >> 16;
	d = sqrt8( x*x + y*y + z*z );
	return d;
}

function int sqrt8(int number)
{
	if(number <= 3)
	{
		if(number > 0)
		{
			return 1;
		}
		return 0;
	}

	int oldAns = number >> 1,                     // initial guess
	    newAns = (oldAns + number / oldAns) >> 1; // first iteration

	// main iterative method
	while(newAns < oldAns)
	{
		oldAns = newAns;
		newAns = (oldAns + number / oldAns) >> 1;
	}

	return oldAns;
}
*/
Function int NoNeg(int Numb)
{
int numfinal;
	if(Numb > 0){numfinal = Numb;}
	else{numfinal = 0;}
return numfinal;
}

//returns the relative pitch of a thing with tid2, from a thing with tid1.
function int GetTargetPitch (int tid1, int tid2)
{
    int x, y, z, xy, a;
    x = GetActorX(tid2) - GetActorX(tid1);
    y = GetActorY(tid2) - GetActorY(tid1);
    z = GetActorZ(tid2) - GetActorZ(tid1);
    a = VectorAngle(x, y);

    if ((a + 0.125) % 0.5 > 0.25)
        xy = FixedDiv(y, sin(a));
    else
        xy = FixedDiv(x, cos(a));

    return -VectorAngle(xy, z);
}

#DEFINE BASEBLASTMIN 120
Script "BlastKnockback" (int BlastThrust, int ThrustForceH, int MaxRadius)
{

int userTID;
int userTeam;
Bool SelfThrustOnly = False;
int ThrustForce = BlastThrust;
	if(ThrustForce < 0) {SelfThrustOnly = true; ThrustForce = ThrustForce*-1;}
int AdditiveForce;
	if(MaxRadius < 0) {AdditiveForce = 1; MaxRadius = MaxRadius*-1;}

	if(ActivatorTID() == 0)
	{
		userTID = ACS_ExecuteWithResult(257, 0);
		userTeam = GetPlayerInfo(userTID - 1000, PLAYERINFO_TEAM);
	}
	else
	{
		userTID = ActivatorTID();
	}
	

int ActX = GetActorX(0);
int ActY = GetActorY(0);
//int ActHeight = GetActorProperty(0,APROP_HEIGHT) >>16;
int Dist;
int distdiff;
int ZThrust;
int XYThrust;
int targetTID;
int PlayerX;
int PlayerY;
int pitch;

int FinalForce;
int FinalForceH;

//int ThrustDrop = NoNeg( (Dist/10) - MaxRadius) << 16;
//SetActivatorToTarget(0);

For(int q = 0;q < ServerMax; q++)
	{
		targetTID = q+1000;
		
		if(!PlayerInGame(q))
		{
			continue;
		}
		
		if( (userTID != targetTID) && (SelfThrustOnly == True)){continue;}
		if(ACS_ExecuteWithResult(975, 1) == 1)
		{
			if(userTeam == GetPlayerInfo(q, PLAYERINFO_TEAM) && userTID != targetTID)
			{
				continue;
			}
		}
		
		//if()
		
		//log(s:"distance is ",i:xyzDistance(0, targetTID));
		if(xyzDistance(0, targetTID) < MaxRadius && checksight(0,targetTID,0) == True
		|| xyzDistance(0, targetTID) <20)
		{
		 Dist = xyzDistance(0,targetTID);
	
		 distdiff = NoNeg(Dist - MaxRadius);
		 pitch = GetTargetPitch(targetTID,0);
		 //VectorAngle(xyDistance(0, targetTID), GetActorZ(0) - GetActorZ(targetTID) >> 16);
		 //log(s:"pitch relative to player ",i:q,s:" is ", f:pitch);
		 //log(s:"Height is  ",i:ActHeight);
		 if(xyzDistance(0, targetTID) > BASEBLASTMIN)
		 {
		 FinalForce = ceil(FixedMul(ThrustForce << 16, 1.0 - FixedDiv(Dist, MaxRadius)));
		 FinalForceH = ceil(FixedMul(ThrustForceH << 16, 1.0 - FixedDiv(Dist, MaxRadius)));
		 }
		 Else
		 {
		 FinalForce = ThrustForce;
		 FinalForceH = ThrustForceH;
		 }
		 ZThrust = (sin(pitch)*-FinalForce); //GetActorPitch(targetTID)
		 XYThrust = (cos(pitch)*-FinalForceH);
		 
		 if (GetActorZ(targetTID) - GetActorFloorZ (targetTID) == 0){XYThrust = FixedMul(XYThrust,1.0);}
		 //log(i:GetActorZ(targetTID) - GetActorFloorZ (targetTID));
		 //log(s:"horizontal thrust is is  ",i:(FixedMul(XYThrust , 1.0 - fixedDiv(distdiff,100)))>> 16);
		 PlayerX = GetActorX(targetTID);
		 PlayerY = GetActorY(targetTID);
		 
		ThrustThing(VectorAngle(ActX - PlayerX,ActY - PlayerY)>>8,(FixedMul(XYThrust , 1.0 - fixedDiv(distdiff,100)))>> 16,1,targetTID);
		thrustthingz(targetTID,(FixedMul(ZThrust , 1.0 - fixedDiv(distdiff,100)))>> 16,1,AdditiveForce);
	}
}

}

