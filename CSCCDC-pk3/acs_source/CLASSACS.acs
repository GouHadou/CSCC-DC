//#library "classacs"

//#include "zcommon.acs"
//#include "cscclib.acs"


script "CSACS_RadiusGive" (int GiveID, int GiveRadius, int GiveType)
{ 
int Target_TID;
int Target_Distance;
int FiringPlayer;
int PlayersTeam;
Bool GiveClearance;

// GiveType 1 = self + Friendlies
// GiveType 2 = Friendlies only
// GiveType 3 = Self only
// GiveType 4 = Enemies only
// GiveType 5 = self + Enemies
// GiveType 6 = All but self
// GiveType 7 = All

If(ActivatorTID() <= 999)
	{
	FiringPlayer= ACS_ExecuteWithResult(257, 0); //Returns the target of the activator
	}
else
	{
	FiringPlayer=ActivatorTID();
	}
PlayersTeam = GetPlayerInfo(FiringPlayer-1000, PLAYERINFO_TEAM);
For(int i = 0;i < ServerMax; i++)
	{
	GiveClearance = True;
	If(!PlayerInGame(i)){Continue;}
	if(!CheckSight(0,i+1000,0)){Continue;}
	If(ACS_ExecuteWithResult(975, 1))
		{
		switch(GiveType)
			{
			case 1:
			If(PlayersTeam != GetPlayerInfo(i, PLAYERINFO_TEAM)){Continue;}
			Break;
			
			case 2:
			If(PlayersTeam != GetPlayerInfo(i, PLAYERINFO_TEAM) || (PlayersTeam == GetPlayerInfo(i, PLAYERINFO_TEAM) && i == FiringPlayer-1000)){Continue;}
			Break;
			
			case 3:
			If(PlayersTeam != GetPlayerInfo(i, PLAYERINFO_TEAM) || (i != FiringPlayer-1000)){Continue;}
			Break;

			case 4:
			If(PlayersTeam == GetPlayerInfo(i, PLAYERINFO_TEAM) || i == FiringPlayer-1000){Continue;}
			Break;
			
			case 5:
			If(PlayersTeam == GetPlayerInfo(i, PLAYERINFO_TEAM) && i != FiringPlayer-1000){Continue;}
			Break;
			
			case 6:
			If(i == FiringPlayer-1000){Continue;}	
			Break;
			}
		}
	else
		{
		switch(GiveType)
			{
			case 1:
			If(i != FiringPlayer-1000){Continue;}
			Break;
			
			case 2:
			If(i == FiringPlayer-1000 || i != FiringPlayer-1000){Continue;}
			Break;
			
			case 3:
			If(i != FiringPlayer-1000){Continue;}
			Break;
			
			case 4:
			If(i == FiringPlayer-1000){Continue;}
			Break;
			
			Default:
			//If(i == FiringPlayer-1000 || i != FiringPlayer-1000){Continue;}
			Break;
			}
		}
	Target_TID = i+1000;
	If(xyzDistance(0,Target_TID) < GiveRadius) // && FiringPlayer!=Target_TID
		{
		GiveActorInventory(Target_TID,"PackageID", GiveID);
		GiveActorInventory(Target_TID,"GivePackage", 1);
		}
	}
}

script "CSACS_MedivisionScript" (int Weapon) CLIENTSIDE
{ 
if(Weapon==1){str WeaponRequired = GetWeapon();}
int Target_TID;
int PlayersTeam;
str TeamTag; 

if(ACS_ExecuteWithResult(975,1)!=1){terminate;}

Switch(PlayerTeam())
	{
	Case 0: TeamTag = "_Light"; Break;
	Case 1: TeamTag = "_Wily"; Break;
	Case 2: TeamTag = "_Cossack"; Break;
	Case 3: TeamTag = "_King"; Break;
	}

while(GetActorProperty(ActivatorTID(), APROP_HEALTH) > 0 && !CheckActorInventory(ActivatorTID(),"CopyRobotUnmorphed"))
	{
	Delay(1);
	if(Weapon==1 && StrIcmp(GetWeapon(),WeaponRequired)!=0){terminate;}
	PlayersTeam = GetPlayerInfo(ActivatorTID()-1000, PLAYERINFO_TEAM);
	For(int p = 0; p < ServerMax; p++)
		{
		If(!PlayerInGame(p)){continue;}
		if(p+1000 == ActivatorTID()){continue;}
		If(PlayersTeam != GetPlayerInfo(p, PLAYERINFO_TEAM)){continue;}
		Target_TID = p+1000;
		If((xyzDistance(0,Target_TID) < 900) && Checksight(0,Target_TID,0))
			{
			if(CheckActorInventory(Target_TID,"CannotUseHealing")){SpawnForced(StrParam(s:TinyBarHealth(Target_TID),s:TeamTag,s:"_NoHeal"),GetActorX(Target_TID),GetActorY(Target_TID),GetActorZ(Target_TID) + (65 << 16));}
			else{SpawnForced(StrParam(s:TinyBarHealth(Target_TID),s:TeamTag),GetActorX(Target_TID),GetActorY(Target_TID),GetActorZ(Target_TID) + (65 << 16));}
			}
		}
	}
}


//Ukiyama Scripts
Script "CSACS_UKIINFO" (int IsExplosion)
{
int ThePlayer = ActivatorTID();
int TotalDamage = ACS_NamedExecuteWithResult("CSACS_UKIDAMAGE", 0, 1);

SetHudSize(800, 680, True);
SetFont("SMALLFONT");
HudMessage(d:(TotalDamage),s:" damage";
HUDMSG_FADEOUT, 1, CR_GOLD, 60.1, 205.1, 5<<16);
SetFont("SMALLFONT");
HudMessage(s:"";
HUDMSG_FADEOUT, 2, CR_GOLD, 60.1, 940.1, 5<<16);
SetFont("SMALLFONT");
HudMessage(s:"";
HUDMSG_FADEOUT, 3, CR_GOLD, 60.1, 920.1, 5<<16);
SetFont("SMALLFONT");
HudMessage(s:"";
HUDMSG_FADEOUT, 4, CR_GOLD, 60.1, 900.1, 5<<16);

If(CheckActorInventory(ThePlayer, "SnipeFlag")){SetFont("SMALLFONT"); HudMessage(s:"+Shot Size -Fire Rate"; HUDMSG_FADEOUT, 2, CR_GOLD, 60.1, 215.1, 5<<16);;}
If(CheckActorInventory(ThePlayer, "RapidFlag")){SetFont("SMALLFONT"); HudMessage(s:"+Fire Rate -Spread"; HUDMSG_FADEOUT, 2, CR_GOLD, 60.1, 215.1, 5<<16);;}
If(CheckActorInventory(ThePlayer, "ShotgunFlag")){SetFont("SMALLFONT"); HudMessage(s:"+Projectiles Fired -Spread -Fire Rate"; HUDMSG_FADEOUT, 2, CR_GOLD, 60.5, 215.5, 5<<16);;}
If(CheckActorInventory(ThePlayer, "GuidedFlag")){SetFont("SMALLFONT"); HudMessage(s:"+Guided"; HUDMSG_FADEOUT, 3, CR_GOLD, 60.1, 225.1, 5<<16);;}
If(CheckActorInventory(ThePlayer, "ArcingFlag")){SetFont("SMALLFONT"); HudMessage(s:"+Arc"; HUDMSG_FADEOUT, 3, CR_GOLD, 60.1, 225.5, 5<<16);;}
If(CheckActorInventory(ThePlayer, "VelocityFlag")){SetFont("SMALLFONT"); HudMessage(s:"+Speed +Ripper"; HUDMSG_FADEOUT, 3, CR_GOLD, 60.1, 225.1, 5<<16);;}
If(CheckActorInventory(ThePlayer, "NerfFlag")){SetFont("SMALLFONT"); HudMessage(s:"+Damage Debuff"; HUDMSG_FADEOUT, 4, CR_GOLD, 60.1, 235.1, 5<<16);;}
If(CheckActorInventory(ThePlayer, "BouncingFlag")){SetFont("SMALLFONT"); HudMessage(s:"+Bouncing"; HUDMSG_FADEOUT, 4, CR_GOLD, 60.1, 235.1, 5<<16);;}
If(CheckActorInventory(ThePlayer, "ExplodingFlag")){SetFont("SMALLFONT"); HudMessage(s:"+EXPLOSIONS?!"; HUDMSG_FADEOUT, 4, CR_GOLD, 60.1, 235.1, 5<<16);;}
}

//Script to handle aiming of Uki's vision
Script "CSACS_UKIREMOTE" (void)
{
int UkiVisionTID = ActivatorTID() - 100;
If(ThingCount(T_NONE, UkiVisionTID))
	{
	ACS_ExecuteAlways(976,0);
	//SetActorState(UkiVisionTID, "RemoteControl");
	SetPlayerProperty(0, 1, 0);
	ChangeCamera(UkiVisionTID, 0, 0);
	Spawnspot("RemoteSFX", UkiVisionTID);
	While(CheckInventory("UkiRemoteFlag"))
		{
		If(GetPlayerInput(-1 , INPUT_BUTTONS) & BT_ATTACK)
			{
			//GiveActorInventory(UkiVisionTID, "UkiAttackFlag", 1);
			GiveInventory("UkiAttackFlag", 1);
			}
		Delay(1);
		}
	}
TakeInventory("UkiRemoteFlag", 1);
SetPlayerProperty(0, 0, 0);
ACS_ExecuteAlways(976,0);
ChangeCamera(0, 0, 0);
Spawnspot("RemoteSFX", 0);
}

//Script for Uki's weapon damage
Script "CSACS_UKIDAMAGE" (int IsExplosion, int Info)
{
int ThePlayer;
If(ActivatorTID() >=1000){ThePlayer = ActivatorTID();}
Else {ThePlayer = ACS_NamedExecuteWithResult("core_gettarget");}

If(ThePlayer < 1000){SetResultValue(10);terminate;}
int TotalDamage = 15;

If(CheckActorInventory(ThePlayer, "SnipeFlag")){TotalDamage += 20;}
If(CheckActorInventory(ThePlayer, "RapidFlag")){TotalDamage -= 5;}
If(CheckActorInventory(ThePlayer, "ShotgunFlag")){TotalDamage -= 6;}

If(CheckActorInventory(ThePlayer, "GuidedFlag")){TotalDamage+=1;}
If(CheckActorInventory(ThePlayer, "ArcingFlag")){TotalDamage += 7;}
If(CheckActorInventory(ThePlayer, "VelocityFlag") && IsExplosion == 0){TotalDamage = CSACS_round(TotalDamage*0.7);}

If(Info==0 && CheckActorInventory(ThePlayer, "ExplodingFlag"))
	{
	Switch(IsExplosion)
		{
		Case 0:
		If(!CheckActorInventory(ThePlayer, "VelocityFlag")){TotalDamage = CSACS_round(TotalDamage*0.1);}
		break;
		
		Case 1:
		TotalDamage = CSACS_round(TotalDamage*0.9);
		break;
		}
	}

If(CheckActorInventory(ThePlayer, "NerfFlag")){TotalDamage += 3;}
SetResultValue(TotalDamage);
}

//Script for the camera for Uki's vision
Script "CSACS_UKIREMOTEAIM" (void) CLIENTSIDE
{
int TargetPlayer= ActivatorTID() + 100;//ACS_ExecuteWithResult(257);
int PlayerPitch = GetActorPitch(TargetPlayer);
int PlayerAngle = GetActorAngle(TargetPlayer);
SetActorPitch(0, PlayerPitch);
SetActorAngle(0, PlayerAngle);
}

//End Ukiyama

////////////////////////////////////LaggyCorperal stuff
script "CSACS_CorpReload" (int ammoTypes, int maxAmmo)  //Reload script.
{
	
	//Ammo types inside and outside the weapon.
	int in, out;
	str inAmmo, outAmmo;
	
	int magSize;//Max ammo inside.
	
	switch(ammoTypes)
	{
		case 1: //Tommy gun	
		inAmmo = "TommyAmmo";
		outAmmo = "FatBullets";
		magSize = 30;
		break;
		Case 2: //Grand Ammo
		inAmmo = "GrandAmmo";
		outAmmo = "ShelbyvilleRound";
		magSize = 8;
		break;
		default:
		print(s:"Specify ammotype ya dork");
		break;
	}
	
	
	in = CheckInventory(inAmmo);
	out = CheckInventory(outAmmo);
	
	//print(s:inAmmo, d:in, s:outAmmo, d:out);
	
	//If maxAmmo is defined, do not reload more than that.
	if (maxAmmo != 0 && magSize > (maxAmmo + in))
	{
		magSize = (maxAmmo + in);
	}
	
	if (out < (magSize-in)) //Can't reload the full weapon
			{
				TakeInventory(outAmmo,out);
				GiveInventory(inAmmo,out);
			}
			else
			{
				TakeInventory(outAmmo, magSize-in);
				GiveInventory(inAmmo, magSize-in);
			}		
	
	
}

//View recoil script
Script "CSACS_CorpRecoil" (int horiz, int vert, int duration) CLIENTSIDE
{
int i, theHecc, oldMove, moveGen, moveAngle, movePitch; 
moveGen = 0;
for (i = 1; i <= duration; i++)
{
	oldMove = moveGen;
	theHecc = sin(((i*0.5)/duration) - 0.25);
	moveGen = ((theHecc) + 1.0)/2;
	moveAngle = fixedmul(horiz, moveGen - oldMove);
	movePitch = fixedmul(vert, moveGen - oldMove);
	
	setActorAngle(0, getActorAngle(0) + moveAngle);
	setActorPitch(0, getActorPitch(0) + moveAngle);
	delay(1);
}
if (getCVAR("CSCCB_CL_RecoilReset") == false) terminate;
delay(1);
moveGen = 0;
horiz = horiz*(-1);
vert = vert*(-1);
for (i = 1; i <= duration; i++)
{
	oldMove = moveGen;
	theHecc = sin(((i*0.5)/duration) - 0.25);
	moveGen = ((theHecc) + 1.0)/2;
	
	moveAngle = fixedmul(horiz, moveGen - oldMove);
	movePitch = fixedmul(vert, moveGen - oldMove);
	
	setActorAngle(0, getActorAngle(0) + moveAngle);
	setActorPitch(0, getActorPitch(0) + moveAngle);
	delay(1);
}
}

//Messatsu
Script "CSACS_MessAbilityCheck" (void)
{
int InputButtons = GetPlayerInput(-1, INPUT_BUTTONS);;
int InputOldButtons = InputButtons;
while (GetActorProperty(ActivatorTID(), APROP_HEALTH) > 0 && CheckInventory("IsMessatsu"))
	{
	InputButtons = GetPlayerInput(-1, INPUT_BUTTONS);
	If(CSCCButtonCheck(InputButtons, InputOldButtons, BT_SPEED|BT_USER1) == 1 )
		{
		If(!CheckInventory("NoParry")){GiveInventory("MessParryFlag", 1);}
		}
	Delay(1);
	InputOldButtons = InputButtons;
	}
}

Script "CSACS_MessSuperItems" (int Super)
{
Switch(Super)
	{
	Case 1:
	TakeInventory("TemaReady", 1);
	TakeInventory("MessatsuAmmo", 18);
	TakeInventory("MessSuperFlag", 56);
	break;

	Case 2:
	TakeInventory("MisogiReady", 1);
	TakeInventory("MessatsuAmmo", 36);
	TakeInventory("MessSuperFlag", 56);
	break;

	Case 3:
	TakeInventory("RagingDemonReady", 1);
	TakeInventory("MessatsuAmmo", 56);
	TakeInventory("MessSuperFlag", 56);
	break;
	}
}

Script "CSACS_DemonFlipCheck" (void)
{
int InputButtons = GetPlayerInput(-1, INPUT_BUTTONS);;
int InputOldButtons = InputButtons;
while (GetActorProperty(ActivatorTID(), APROP_HEALTH) > 0 && CheckInventory("DemonFlipActive"))
	{
	InputButtons = GetPlayerInput(-1, INPUT_BUTTONS);
	If(CSCCButtonCheck(InputButtons, InputOldButtons, BT_ATTACK) == 1 )
		{
		GiveInventory("MessPalm", 1);
		terminate;
		}
	If(CSCCButtonCheck(InputButtons, InputOldButtons, BT_ALTATTACK) == 1 )
		{
		GiveInventory("MessKick", 1);
		terminate;
		}
	Delay(1);
	InputOldButtons = InputButtons;
	}

}


Script "CSACS_MessParryHealth" (int CurrentHealth)
{
int PlayerTID = ActivatorTID();

Do
	{
	If(CurrentHealth < GetActorProperty(PlayerTID, APROP_HEALTH)){CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);}
	If(CurrentHealth > GetActorProperty(PlayerTID, APROP_HEALTH))
		{
		If(CheckInventory("OverhealValue") && (CurrentHealth - GetActorProperty(PlayerTID, APROP_HEALTH))<5)
			{
			CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
			}
		Else
			{
			GiveInventory("MessParrySuccess", 1);
			SetActorProperty(0,APROP_HEALTH,(CurrentHealth));
			}
		}
	Delay(1);
	}
While(CheckInventory("MessParry") || CheckInventory("ParryBlock"));
}
Script "CSACS_MessAmmoCheck" (int AmmoGive, int distance)
{
If(ACS_NamedExecuteWithResult("CSACS_MessEnemyProximity", distance)==TRUE){GiveInventory("MessatsuAmmo", AmmoGive);}
}

Script "CSACS_MessEnemyProximity" (int distance)
{
int ReturnValue = 0;
int PlayerTID = ActivatorTID();
int CurrentTeam = GetPlayerInfo(PlayerNumber(), PLAYERINFO_TEAM);
For(int i = 0; i < 64; i++)
	{
	If(PlayerInGame(i))
		{
		If(i==PlayerNumber()){continue;}
		Switch(ACS_ExecuteWithResult(975, 1))
			{
			Case 0:
			If(XYZDistance(PlayerTID, i+1000) < distance)
				{
				If(CheckSight(PlayerTID, i+1000, 0))
					{
					ReturnValue=1; 
					i=64;
					GiveInventory("MessMeterOkay", 1);
					}
				Else
					{
					If(CheckInventory("MessMeterOkay"))
						{
						ReturnValue=1; 
						i=64;
						}
					}
				}
			break;
			Case 1:
			If(CurrentTeam == GetPlayerInfo(i, PLAYERINFO_TEAM)){continue;}
			If(XYZDistance(PlayerTID, i+1000) < distance)
				{
				If(CheckSight(PlayerTID, i+1000, 0))
					{
					ReturnValue=1; 
					i=64;
					GiveInventory("MessMeterOkay", 1);
					}
				Else
					{
					If(CheckInventory("MessMeterOkay"))
						{
						ReturnValue=1; 
						i=64;
						}
					}
				}
			break;
			}
		}
	}
SetResultValue(ReturnValue);
}

Script "CSACS_MessDamageAmmo" (void)
{
Delay(1);
int PlayerTID = ActivatorTID();
int CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);

while(GetActorProperty(PlayerTID, APROP_HEALTH) > 0 && CheckInventory("MessatsuWep"))
	{
	While(CurrentHealth <= GetActorProperty(PlayerTID, APROP_HEALTH))
		{
		Delay(1);
		If(GetActorProperty(PlayerTID, APROP_HEALTH) > CurrentHealth)
			{
			CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
			}
		}
	If(GetActorProperty(PlayerTID, APROP_HEALTH) > 0)
		{
		GiveActorInventory(PlayerTID, "MessatsuAmmo", (CurrentHealth - GetActorProperty(PlayerTID, APROP_HEALTH))/3);
		CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
		}
	}
}

//Ice/Sparky
Script "CSACS_IceSparkyFusion" (void)
{
Delay(1);
int PlayerTID = ActivatorTID();
int FusionStock = CheckInventory("FusionStock");
If(FusionStock < 1){FusionStock = 1;}
int CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);

while(GetActorProperty(PlayerTID, APROP_HEALTH) > 0 && (CheckInventory("IceWep") || CheckInventory("SparkyWep")))
	{
	While(CurrentHealth <= GetActorProperty(PlayerTID, APROP_HEALTH))
		{
		Delay(1);
		If(CheckInventory("FusionMeter")>=250)
			{
			TakeInventory("FusionMeter", 999);
			GiveInventory("IceSparkyCombine", 1);
			}
		If(GetActorProperty(PlayerTID, APROP_HEALTH) > CurrentHealth)
			{
			CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
			}
		}
	If((CurrentHealth - GetActorProperty(PlayerTID, APROP_HEALTH) == 1) && (GetActorProperty(PlayerTID, APROP_HEALTH) > GetActorProperty(PlayerTID, APROP_SpawnHealth)))
		{
		CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
		continue;
		}
	FusionStock = CheckInventory("FusionStock");
	If(GetActorProperty(PlayerTID, APROP_HEALTH) > 0)
		{
		If(!CheckInventory("IceSparkyFusion") && !CheckInventory("IceSparkyCombine"))
			{
			GiveActorInventory(PlayerTID, "FusionMeter", (CurrentHealth - GetActorProperty(PlayerTID, APROP_HEALTH))*FusionStock);
			}
		CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
		}
	}
}

#DEFINE FUSIONTIMER 15*35
Script "IceSparkyTimer" (void)
{
int TimerRemaining = FUSIONTIMER;
While(GetActorProperty(0, APROP_HEALTH) > 0 && TimerRemaining > 0 && GetGamemodeState() == 2)
	{
	SetInventory("FusionTimer",TimerRemaining);
	TimerRemaining--;
	Delay(1);
	}
TakeInventory("IceSparkyFusion", 1);
SetInventory("FusionTimer",0);
SetInventory("FusionStock", 1);
}

script "CSACS_IceSparkSwap" (int speed)
{

Switch(speed)
	{
	Case 0:
	SetActorProperty(0,APROP_SPEED,1.0);
	SetActorProperty(0,APROP_JUMPZ,10.0);
	break;
	
	Case 1:
	SetActorProperty(0,APROP_SPEED,1.45);
	SetActorProperty(0,APROP_JUMPZ,14.0);
	break;
	}

}

//Tank Operator
function bool checkForMovement(int buttons) {
	int result = 1;

	if (buttons & BT_MOVERIGHT){
		result+=2;
	}
	if (buttons & BT_MOVELEFT){
		result+=4;
	}
	if (buttons & BT_BACK){
		result+=8;
	}
	if (buttons & BT_FORWARD){
		result+=16;
	}

	return(result);
}

function int fdistanceVal (int x, int y, int z)
{
	int len;

	int ang = vectorangle(x,y);
	if(((ang+0.125)%0.5) > 0.25) len = fixeddiv(y, sin(ang));
	else len = fixeddiv(x, cos(ang));

	ang = vectorangle(len, z);
	if(((ang+0.125)%0.5) > 0.25) len = fixeddiv(z, sin(ang));
	else len = fixeddiv(len, cos(ang));

	return len;
}

script "CSACS_Tank_ProjectilePort" (int maxDist) //Borrowed from cbm
{
int target = ACS_ExecuteWithResult(257);

if(getActorProperty(0,APROP_HEALTH) <= 0 || getActorProperty(target,APROP_HEALTH) <= 0) {
	terminate;
}

maxDist = maxDist << 16;

int xDiff = getActorX(0) - getActorX(target);
int yDiff = getActorY(0) - getActorY(target);
int zDiff = getActorZ(0) - getActorZ(target);

if(fdistanceVal(xDiff,yDiff,zDiff) > maxDist) {
	terminate;
}

while (true) {
	xDiff += getActorVelX(0);
	yDiff += getActorVelY(0);
	zDiff += getActorVelZ(0);
	SetActorVelocity(target, xDiff, yDiff, zDiff, 0, 0);
	//Log(s:"MOVED");
	//GiveActorInventory(target,"ProjectilePorting",1);

	delay(1);

	if(getActorProperty(0,APROP_HEALTH) <= 0 || getActorProperty(target,APROP_HEALTH) <= 0 || CheckInventory("ProjectilePortDead")) {
		//Log(s:"Someone is Dead");
		GiveActorInventory(target,"ProjectilePortDead",1);
		//TakeActorInventory(target,"ProjectilePorting",1);
		terminate;
	}
	xDiff = getActorX(0) - getActorX(target);
	yDiff = getActorY(0) - getActorY(target);
	zDiff = getActorZ(0) - getActorZ(target);
	if(fdistanceVal(xDiff,yDiff,zDiff) > maxDist) {
		//Log(s:"Someone is too far");
		SetActorState(0,"Death",1);
		GiveActorInventory(target,"ProjectilePortDead",1);
		//TakeActorInventory(target,"ProjectilePorting",1);
		terminate;
	}

}
}

script "CSACS_Tank_CheckButtons" (void) {SetResultValue(checkForMovement(GetPlayerInput(-1, INPUT_BUTTONS)));}
script "CSACS_Tank_ChangeAngle" (int tid, int newangle) {SetActorAngle(tid,GetActorAngle(tid)+newangle);}

script "CSACS_Tank_SetTankSpecies" (int enable)
{
	Switch(enable) {
	Case 1:
	SetActorProperty(0,APROP_ViewHeight,64.0);
	break;
	Case 0:
	SetActorProperty(0,APROP_ViewHeight,41.0);
	break;
	}
}

script "CSACS_Tank_Speedster" (int tid, int tspeed)
{
	Switch(tspeed) {
	
	Case 1:
		GiveActorInventory(tid,"Tank_SpeedForwB",1); 
	break;
	Case 2:
		GiveActorInventory(tid,"Tank_SpeedBackB",1); 
	break;
	}
}

Script "CSACS_Tank_ArmorConvert" (int Version)
{
int PlayerResource = CheckInventory("TankRepairAmmo");
int PlayerHPResource = CheckInventory("TankHPAmmo");
int PlayerHP = GetActorProperty(0,APROP_HEALTH);
int Output;
Switch(Version)
	{
	Case 0:
	SetPlayerProperty(0, 1, PROP_BUDDHA);
	SetInventory("TankHPAmmo",PlayerHP);
	SetActorProperty(0,APROP_SPAWNHEALTH,GetAmmoCapacity("TankRepairAmmo"));
	SetActorProperty(0,APROP_HEALTH,PlayerResource);
	Break;
	Case 1:
	SetInventory("TankRepairAmmo",PlayerHP);
	SetActorProperty(0,APROP_SPAWNHEALTH,100);
	SetActorProperty(0,APROP_HEALTH,PlayerHPResource);
	SetPlayerProperty(0, 0, PROP_BUDDHA);
	Break;
	}

}

Script "CSACS_ArmorHitSensor" (Void)
{
int PlayerArmor = checkInventory("BasicArmor");
int PlayerArmorNow;
GiveInventory("ArmorHitSensorFlag",1);
Delay(3);

while(checkInventory("ArmorHitSensorFlag"))
	{
		PlayerArmorNow = checkInventory("BasicArmor");
		if(PlayerArmorNow <= 0){TakeInventory("ArmorHitSensorFlag",99);}
		if(PlayerArmor != PlayerArmorNow)
		{
			GiveInventory("ArmorHitSound",1);
			PlayerArmor = PlayerArmorNow;
		}
	Delay(1);
	}

}

//Korby
Script "KorbyBlueMagicAbsorb" (void)
{
int PlayerTID = ActivatorTID();
int BeforeHealth = CheckInventory("KorbyHealthFlag");
If (BeforeHealth <= 0){Terminate;}
SetPlayerProperty(0, 1, PROP_BUDDHA);
int BMHealth = 999;
int CurrentHealth = BMHealth;
int Diff= 0;
int BMValue = 0;
int Hits = 0;
int i;
bool GiveInvuln = TRUE;
int TakeAmmo = 3;

SetActorProperty(PlayerTID, APROP_Health, BMHealth);
TakeActorInventory(PlayerTID, "KorbyHealthFlag", 999);
While(CheckInventory("BMHoldFlag"))
	{
	i=0;
	Diff = CurrentHealth - GetActorProperty(PlayerTID, APROP_Health);
	
	If(Hits >= 5){break;}
	If(BMValue > 0 && Diff == 0){break;}
	If(Diff > 0)
		{
		BMValue+=Diff;
		Hits++;
		SetActorProperty(PlayerTID, APROP_Health, BMHealth);
		CurrentHealth = GetActorProperty(PlayerTID, APROP_Health);
		If(BMValue > 200){GiveInvuln=FALSE;break;} //Can't absorb pits or quickbeams.
		If(BMValue > 100){break;} 
		For(i = 0; i <5; i++)
			{
			Delay(1);
			Diff = CurrentHealth - GetActorProperty(PlayerTID, APROP_Health);
			If(Diff > 0){i=100;}
			}
		}
	If(i<10)
		{
		If(TakeAmmo >= 3 && BMValue == 0){TakeInventory("MP", 1);TakeAmmo=0;}
		Else{TakeAmmo++;}
		Delay(1);
		}
	}
If(BMValue > 0)
	{
	//PrintBold(i:BMValue);
	If(GiveInvuln == TRUE){GiveInventory("KorbyTempInvuln", 1);}
	GiveActorInventory(PlayerTID, "BMFlag", 1);
	If(BMValue >= 2 && BMValue < 10){GiveActorInventory(PlayerTID, "THOUF", 1);}
	If(BMValue >= 10 && BMValue < 20){GiveActorInventory(PlayerTID, "AQUAF", 1);}
	If(BMValue >= 20 && BMValue < 30){GiveActorInventory(PlayerTID, "LIMIF", 1);}
	If(BMValue >= 30 && BMValue < 40){GiveActorInventory(PlayerTID, "FLAMF", 1);}
	If(BMValue >= 40 && BMValue < 50){GiveActorInventory(PlayerTID, "BLASF", 1);}
	If(BMValue >= 50 && BMValue < 60){GiveActorInventory(PlayerTID, "FLASF", 1);}
	If(BMValue >= 60 && BMValue < 70){GiveActorInventory(PlayerTID, "TIMEF", 1);}
	If(BMValue >= 70 && BMValue < 80){GiveActorInventory(PlayerTID, "WHITF", 1);}
	If(BMValue >= 80 && BMValue < 90){GiveActorInventory(PlayerTID, "MANTF", 1);}
	If(BMValue >= 90 && BMValue < 100){GiveActorInventory(PlayerTID, "SELFF", 1);}
	If(BMValue >= 100){GiveActorInventory(PlayerTID, "BADBF", 1);}
	If(BMValue == 1){GiveActorInventory(PlayerTID, "SELFF", 1);} //Korby, WHY?!
	}
SetActorProperty(PlayerTID, APROP_Health, BeforeHealth);
SetPlayerProperty(0, 0, PROP_BUDDHA);
}

//Pistonman
Script "CSACS_PistonFistFX" (int playerTid, int arm, int Player_Team) CLIENTSIDE
{
	str P_team = "";
	str ArmType = "";
	if(arm==2){ArmType = "2";}
	if(arm==1){ArmType = "1";}
    int plX; int plY;  int plZ;
    int grX; int grY;  int grZ;
    int vX;  int vY;   int vZ;
    int nX;  int nY;   int nZ;
    int bX;  int bY;   int bZ;
    int magnitude;
    int pointCount;
    int pointOffset;
	int density = 24;
	switch(Player_Team)
		{
		Case 0:
		P_team = "B";
		break;
		Case 1:
		P_team = "R";
		break;
		Case 2:
		P_team = "G";
		break;
		Case 3:
		P_team = "Y";
		break;
		}

	str SpawnName = StrParam(s:"PistonCoilFX", s:ArmType, s:P_team);

	while((ClassifyActor(0) == 128||ClassifyActor(0) == 256) && GetActorProperty(playerTid, APROP_HEALTH)>0){

		plX = GetActorX(playerTid); grX = GetActorX(0);
		plY = GetActorY(playerTid); grY  = GetActorY(0);
		plZ = GetActorZ(playerTid)+(14 << 16); grZ  = GetActorZ(0);
		//+14 to the spawn height of ^the player so the chain doesn't spawn from their feet.
		vX = grX - plX;   vY = grY - plY;   vZ = grZ - plZ;

		magnitude = magnitudeThree(vX >> 16, vY >> 16, vZ >> 16);

		pointCount  = magnitude / density;
		pointOffset = magnitude - (pointCount * density);


		//if(grX == 0 && grY == 0 && grZ == 0){terminate;} 

		if (magnitude != 0)
		{
			nX = vX / magnitude; nY = vY / magnitude; nZ = vZ / magnitude;

			int i; int j;
			for (i = 0; i < pointCount; i++)
			{
				j = (i * density) + pointOffset;

				bX = (nX * j) + plX;
				bY = (nY * j) + plY;
				bZ = (nZ * j) + plZ;//+(16 << 16);

				Spawn(SpawnName, bX, bY, bZ);
			}
		}
		Delay(1);
	}
}



script "BadzWarp" (void){
	int xspeed = GetActorVelX(ActivatorTID());
	int yspeed = GetActorVelY(ActivatorTID());
	int zspeed = GetActorVelZ(ActivatorTID());
	ThrustThing(GetActorAngle(ActivatorTID()) >> 8,128,1,0);
	Delay(1);
	SetActorVelocity(0,xspeed,yspeed,zspeed,false,false);
}


script "BULL_SLEEPER" (int time)
{
	int CurrentHP = GetActorProperty(0,APROP_Health);
	int RegHP = GetActorProperty(0,APROP_Health);
	
	while(CurrentHP > 0) {
		CurrentHP = GetActorProperty(0,APROP_Health);
		if(CurrentHP < RegHP) {
			GiveActorInventory(0,"UnSleeperTag",1);
			//Log(s:"UnSleeperTag given");
			terminate;
		}
		Delay(1);
		if(time <= 0) {
			GiveActorInventory(0,"UnSleeperTag",1);
			//Log(s:"UnSleeperTag given - timed");
			terminate;
		}
		time--;
	}
}

//======|Damage Faloff Formula Script
Script "DamageRate" (int ModDamage, int DistStart, int RampRate) //DamageDropoff Script
{
int Damage = NoNeg(ModDamage - NoNeg(xyzdistance(0, ACS_ExecuteWithResult(257, 0))-DistStart)/RampRate);
SetResultValue(Damage);
}

// Returns a number below 0 as 0
Function int NoNeg (int Numb)
{
Int Output;

if(Numb > 0){Output = Numb;}
else{Output = 0;}
return Output;
}


Script "LightScreenSyncher" (void) 
{
	//int Player = ACS_NamedExecuteWithResult("core_gettarget",0);
	int BaseTID = ActivatorTID()-1000;
	int Deduction;
	// Loop if the base is active still
	while(GetUserVariable(BaseTID, "User_ScreenHP")>0
	&& ThingCount(T_NONE,BaseTID) > 0
	){
	if (GetActorProperty(0, APROP_HEALTH) != GetActorProperty(0, APROP_SPAWNHEALTH))
		{
		Deduction = GetActorProperty(0, APROP_SPAWNHEALTH) - GetActorProperty(0, APROP_HEALTH);
		Healthing(9999);
		SetUserVariable(BaseTID, "User_ScreenHP",GetUserVariable(BaseTID, "User_ScreenHP")-Deduction);
		}
		//TakeActorInventory(Player,"LightScreenHealth",999);
		//GiveActorInventory(Player,"LightScreenHealth",GetUserVariable(BaseTID, "User_ScreenHP"));
		Delay(1);
	}
	
	// Remove
	Thing_Remove(0);
}

Script "LightScreenKiller" (Void)
{
int Player = ACS_NamedExecuteWithResult("core_gettarget",0);

	//While(ThingCount(T_NONE,4000+(Player))
	//||ThingCount(T_NONE,5000+(Player))
	//)
	//{
	SetActorState (4000+(Player), "Perish");
	SetActorState (5000+(Player), "Perish");
	//}
}

Script "ScreenHealthSynch" (VOID)
{
int BaseTID = ActivatorTID();
int TargetTID = ACS_ExecuteWithResult(257,0);

	while(GetUserVariable(BaseTID, "User_ScreenHP")>0
	&& ThingCount(T_NONE,BaseTID) > 0
	){
		TakeActorInventory(TargetTID,"LightScreenHealth",999);
		GiveActorInventory(TargetTID,"LightScreenHealth",GetUserVariable(BaseTID, "User_ScreenHP"));
		Delay(1);
	}
}


Script "Aegis_ShieldCheck" (int on_self)
{
int TargetTID;
int TargShieldEnergy;
int HealthReturn;
// for the deploy shield, check how much shield energy the player has
if(on_self > 0){TargetTID = ActivatorTID();}
	Else{TargetTID = ACS_ExecuteWithResult(257,0);}

	TargShieldEnergy = CheckActorInventory(TargetTID,"ShieldEnergy");
	HealthReturn = ValueMap(TargShieldEnergy,150,1,250,1);
	//log(i:TargShieldEnergy,s:" to ",i:HealthReturn); 
SetResultValue(HealthReturn);
}

Script "Aegis_ShieldEnergySynch" (void)
{

int BaseTID = ActivatorTID();
int TargetTID = ACS_ExecuteWithResult(257,0);
int ScreenHealth = (GetUserVariable(BaseTID, "User_ScreenHP") ); //- 200

int ShieldReturn; 

TakeActorInventory(TargetTID,"LightScreenHealth",9999);
TakeActorInventory(TargetTID,"ShieldEnergy",999);
if (ScreenHealth > 0)
	{
		ShieldReturn = ValueMap(ScreenHealth,250,1,150,1);
		GiveActorInventory(TargetTID,"ShieldEnergy",ShieldReturn);
	}
	Else{GiveActorInventory(TargetTID,"K_ShieldBreak",1);}
}

Script "Aegis_ShieldLifeSap" (void)
{

int BaseTID = ActivatorTID();
int TargetTID = ACS_ExecuteWithResult(257,0);

If(!PlayerInGame(TargetTID-1000)){SetUserVariable(BaseTID, "User_ScreenHP",GetUserVariable(BaseTID, "User_ScreenHP")-5);}

}

Script "WepBloomStat" (void)
{
int FiringPlayer= ACS_ExecuteWithResult(257, 0);
SetResultValue(checkactorinventory(FiringPlayer,"WepBloomItem"));
}

Script "PlayerSpeciesSynch" (VOID)
{
int TargetTID = ACS_ExecuteWithResult(257,0);
SetActorProperty(0,APROP_SPECIES,GetActorProperty(TargetTID,APROP_SPECIES));
}

//=======|Yang

Script "YangKnockback" (void)
{
int KnockBack = CheckInventory("YangKnockBackFlag");
TakeInventory("YangKnockBackFlag", 999);
If(KnockBack < 10){KnockBack = 10;}
If(KnockBack > 50){KnockBack = 50;}
ACS_NamedExecuteAlways("CSACS_HitKnockback",0,KnockBack);
}

Script "YangPower" (int PlayerTID, int Divisor)
{
int ReturnValue = 10;
int YangSpeed = CurrentSpeedXYZ(PlayerTID);
If(YangSpeed > 20){YangSpeed = 20;}
int YangMultiplier = FixedDiv(YangSpeed, 10);
int Semblance = CheckActorInventory(PlayerTID, "YangSemblance");
If(Divisor <=0)
	{
	ReturnValue += Semblance;
	}
Else
	{
	ReturnValue += (Semblance/Divisor);
	}

if(YangMultiplier > 1.0)
	{
	ReturnValue = FixedMul(ReturnValue-10, YangMultiplier)+10;
	}
//printbold(i:ReturnValue);
SetResultValue(ReturnValue);
}


#DEFINE DashForce 16
#DEFINE DashCoolDown 25

script "YangBoost" (Void)
{
int InputButtons; 
int InputOldButtons; 
int InputOldBoost;
Bool SpeedPressed = FALSE;
Bool SameMovement = FALSE;
int HasUsedMovement;
int HDashForce;
int ThrustDir;
int AngleCount;
if(PlayerIsBot(PlayerNumber())){terminate;}

while(GetActorProperty(ActivatorTID(), APROP_HEALTH) > 0 && CheckInventory("IsYang"))
	{
	While(CheckActorInventory(ActivatorTID(), "EmberCelicaAmmo") < 2)
		{
		Delay(1);
		If(GetActorProperty(ActivatorTID(), APROP_HEALTH) <= 0 || !CheckInventory("IsYang")){terminate;}
		If(CheckActorInventory(ActivatorTID(), "YangDashCoolDown") > 0){TakeActorInventory(ActivatorTID(), "YangDashCoolDown", 1);}
		}
	ThrustDir = 0;
	AngleCount = 0;
	HDashForce = DashForce - CheckActorInventory(ActivatorTID(), "YangDashCoolDown") ;
	If(HDashForce < 1){HDashForce = 1;}
	
	InputButtons = GetPlayerInput(-1, INPUT_BUTTONS);
	HasUsedMovement=0;

	SpeedPressed = CSCCButtonCheck(InputButtons, InputOldButtons, BT_SPEED|BT_USER1) == 1;
	
	If(SpeedPressed && (InputButtons & BT_BACK))
		{
		ThrustDir+=0.5;
		AngleCount++;
		GiveInventory("EmberCelicaBoost", 1);
		HasUsedMovement=2;
		If(InputOldBoost & BT_BACK){SameMovement = TRUE;}
		}
	If(SpeedPressed && (InputButtons & BT_MOVELEFT))
		{
		AngleCount++;
		ThrustDir+=0.25;
		GiveInventory("EmberCelicaBoost", 1);
		HasUsedMovement=2;
		If(InputOldBoost & BT_MOVELEFT){SameMovement = TRUE;}
		}
	If(SpeedPressed && (InputButtons & BT_MOVERIGHT))
		{
		ThrustDir+=0.75;
		AngleCount++;
		GiveInventory("EmberCelicaBoost", 1);
		HasUsedMovement=2;
		If(InputOldBoost & BT_MOVERIGHT){SameMovement = TRUE;}
		}
	If(SpeedPressed && (InputButtons & BT_FORWARD))
		{
		If(ThrustDir > 0.5){ThrustDir+=1.0;}
		AngleCount++;
		GiveInventory("EmberCelicaBoost", 1);
		HasUsedMovement=2;
		If(InputOldBoost & BT_FORWARD){SameMovement = TRUE;}
		}
	If(AngleCount>0)
	{
	ThrustDir=(GetActorAngle(ActivatorTID())+(ThrustDir/AngleCount))<<8;
	ThrustThing((ThrustDir)>>16, HDashForce, 1, 0);
	}
	//Jump Boost
	If(CSCCButtonCheck(InputButtons, InputOldButtons, BT_JUMP) == 1 || (HasUsedMovement > 0 && CSCCButtonCheck(InputButtons, InputOldButtons, BT_JUMP) == 3))
		{
		If((GetActorZ(0) - GetActorFloorZ(0)) >= 32.0)
			{
			SetActorVelocity(0, GetActorVelX(0), GetActorVelY(0), GetActorProperty(0, APROP_JUMPZ), 0, 0);
			TakeInventory("JumpCancler", 1);
			GiveInventory("EmberCelicaBoost", 1);
			If(HasUsedMovement == 0){HasUsedMovement=1;}
			}
		}
			
	// Neutral movement
	If(SpeedPressed && HasUsedMovement == 0)
		{
		If(GetActorVelZ(0) == 0)
			{
			SetActorVelocity(0, GetActorVelX(0), GetActorVelY(0), FixedMul(GetActorProperty(0, APROP_JUMPZ),1.5), 0, 0);
			TakeInventory("JumpCancler", 1);
			If(HasUsedMovement == 0){HasUsedMovement=1;}
			}
		Else
			{
			SetActorVelocity(0, GetActorVelX(0), GetActorVelY(0), -FixedMul(GetActorProperty(0, APROP_JUMPZ),1.25), 0, 0);
			TakeInventory("JumpCancler", 1);
			GiveInventory("EmberCelicaDown", 1);
			If(HasUsedMovement == 0){HasUsedMovement=1;}
			}
		}
	If(CheckActorInventory(ActivatorTID(), "YangDashCoolDown") > 0){TakeActorInventory(ActivatorTID(), "YangDashCoolDown", 1);}
	If(HasUsedMovement>0)
		{
		GiveActorInventory(ActivatorTID(), "BoostExplodeItem", 1);
		TakeActorInventory(ActivatorTID(), "EmberCelicaAmmo", 2);
		If(HasUsedMovement > 1)
			{
			Switch(SameMovement)
				{
				Case TRUE:
				GiveActorInventory(ActivatorTID(), "YangDashCoolDown", DashCoolDown/2);
				break;
				Case FALSE:
				GiveActorInventory(ActivatorTID(), "YangDashCoolDown", DashCoolDown);
				break;
				}
			InputOldBoost = InputButtons;
			}
		LimitSpeed(30);
		}
	SameMovement = FALSE;
	delay(1);	
	InputOldButtons = InputButtons; // More reliable than INPUT_OLDBUTTONS ....Go figure.
	}
}

/*
Script "YangSpeedCheck" (void)
{
If(ActivatorTID() < 1000)
	{
	SetResultValue(CurrentSpeedXYZ(ACS_ExecuteWithResult(257,0)));
	}
Else
	{
	SetResultValue(CurrentSpeedXYZ(ActivatorTID()));
	}
}
*/
Script "YangAura" (int mode)
{
If(ActivatorTID() < 1000)
	{
	SetActivatorToTarget(0);
	}
Switch(mode)
	{
	Case 1:
	SetResultValue(CheckInventory("YangSemblance"));
	break;
	Default:
	SetResultValue(CheckInventory("BasicArmor"));
	break;
	}
}

Script "YangSemblanceChecker" (void)
{
Delay(2);
int PlayerTID = ActivatorTID();
int CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
int CurrentAura = CheckActorInventory(PlayerTID, "BasicArmor");
int SemblanceGive;
while(GetActorProperty(PlayerTID, APROP_HEALTH) > 0 && CheckWeapon("EmberCelica"))
	{
	While(CurrentHealth + CurrentAura <= GetActorProperty(PlayerTID, APROP_HEALTH) + CheckActorInventory(PlayerTID, "BasicArmor"))
		{
		Delay(1);
		If(GetActorProperty(PlayerTID, APROP_HEALTH) > CurrentHealth)
			{
			CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
			}
		If(CheckActorInventory(PlayerTID, "BasicArmor") > CurrentAura)
			{
			CurrentAura = CheckActorInventory(PlayerTID, "BasicArmor");
			}
		}
	If(GetActorProperty(PlayerTID, APROP_HEALTH) > 0)
		{
		SemblanceGive = ((CurrentAura - CheckActorInventory(PlayerTID, "BasicArmor")) + (CurrentHealth - GetActorProperty(PlayerTID, APROP_HEALTH)));
		If(CheckActorInventory(PlayerTID, "YangBlocking")){SemblanceGive = SemblanceGive*4;}
		GiveActorInventory(PlayerTID, "YangSemblance", SemblanceGive);
		CurrentAura = CheckActorInventory(PlayerTID, "BasicArmor");
		CurrentHealth = GetActorProperty(PlayerTID, APROP_HEALTH);
		}
	//printbold(s: "Health - ", i: CurrentHealth, s:" - Armor - ", i:CurrentAura);
	}
} 

Script "OBJECTTALLY" (int BaseNum)
{
int MasterTID = ACS_ExecuteWithResult(257, 0);

// objects work within the 3000's range, the playernumber being in the 100th place
//Naturally this means a single player can only have up to 9 items
if (BaseNum < 3000){BaseNum = 3000;}

int ObjTIDBase = BaseNum + ((MasterTID-1000)*100);
bool TIDset = false;
int TIDCount;

while(!TIDset)
{
if(ThingCount(T_NONE,ObjTIDBase+TIDCount))
	{
	//log(s:"Object with TID ",i:ObjTIDBase+TIDCount,s:" Already exists");
	TIDCount++;
	//continue;
	}
	Else
	{
	//log(s:"This object's TID is now ",i:ObjTIDBase+TIDCount,s:"!");
	Thing_ChangeTID(0,ObjTIDBase+TIDCount);
	//log(s:"This object's TID is now ",i:ActivatorTID(),s:"!");
	TIDset = true;
	}
}

for(int i; i < 9; i++)
{
SetUserVariable(ObjTIDBase+i,"User_Tally",GetUserVariable(ObjTIDBase+i,"User_Tally")+1);
//log(s:"Object with TID ",i:ObjTIDBase+i,s:" Now has a tally of ",i:GetUserVariable(ObjTIDBase+i,"User_Tally"));
}
//--
}

Script "OBJECTDEATHTALLY" (VOID)
{
int MasterTID = ACS_ExecuteWithResult(257, 0);
int ObjTIDBase = 3000 + ((MasterTID-1000)*100);

// ment to be called when an object dies, this makes all objects drop their tally by 1. if their tally was above
//the one that died. this is only for if the object was destroyed, not terminated due to being overtallied
int ObjTID = ActivatorTID();
int EmptyTally = GetUserVariable(ObjTID,"User_Tally");
//log(s:"object ",i:ObjTID ,s:" was destroyed!");

for(int i; i < 9; i++)
{
	if(GetUserVariable(ObjTIDBase+i,"User_Tally") > 1)
	{
	SetUserVariable(ObjTIDBase+i,"User_Tally",GetUserVariable(ObjTIDBase+i,"User_Tally")-1);
	//log(s:"Object with TID ",i:ObjTIDBase+i,s:" Now has a new tally of ",i:GetUserVariable(ObjTIDBase+i,"User_Tally"));
	}
}

}

Script "DEPLPOYABLEDELETER" (int gone) DISCONNECT
{
//log(i:gone);
int ObjTIDBase = 3000 + ((gone)*100);
int ObjTIDBase2 = 4000 + ((gone)*100);
int ObjTIDBase3 = 4000 + ((gone)+1000);
int ObjTIDBase4 = 5000 + ((gone)+1000);
for(int i; i < 9; i++)
{
	SetActorState (ObjTIDBase+i, "Perish");
	SetActorState (ObjTIDBase2+i, "Perish");

}

	SetActorState (ObjTIDBase3, "Perish");
	SetActorState (ObjTIDBase4, "Perish");
}

Script "CSCC_Prism" (void) // Lol Name Refrence 
{
int x = GetActorProperty(0,APROP_SpawnHealth); 
int y = GetActorProperty (0, APROP_HEALTH);
int TotalDamage = (x-y);
SetResultValue(TotalDamage);
}

script "PitchGrab" (Void)
{
int FiringPlayer= ACS_ExecuteWithResult(257, 0);
int Output = 360 * (GetActorPitch(FiringPlayer));

Setresultvalue(Output >> 16);

//--
}



//MAX_TARGET_ANGLE (0.0 - 0.5) i think
#DEFINE MAX_TARGET_ANGLE 0.005
#DEFINE MAX_TARGET_ANGLE2 0.0005
#DEFINE TEAM_NONE -1
#DEFINE TEAM_COOP -2

#DEFINE LOSAMMO_MAX 300

//just using this until GetActorProperty(0,APROP_Height)/2 works
#DEFINE PLAYER_CENTER 28.0

int targetRegister; //replaced with User_STargTID
int angleDistRegister; // replaced with User_angleDistRegister



script "TracerTargeter" (int TargType, int TargRange) {
	int ownerNumber = PlayerNumber();
	int team;
	int x;
	int y;
	int z;
	int angle;
	int pitch;
	int i;
	
	str WepName = getweapon();
	//log(s:WepName);
	// each instance of this script is tied to a weapon, when you are off of it, it terminates
	
	//if(CheckInventory("TargScriptActive")){Terminate;}
		//an instance of this script is already live for this person
	
	if (TargRange<=0){setuservariable(0,"User_STargRange",600); 
					  adjustInventory("TargetingRangeFlag",getuservariable(0,"User_STargRange")+1);}
	else{setuservariable(0,"User_STargRange",TargRange);
		adjustInventory("TargetingRangeFlag",getuservariable(0,"User_STargRange")+1);}
	
	GiveInventory("TargActive",1);
	
	while(GetActorProperty(0,APROP_HEALTH) > 0 
			&& Checkinventory("TargActive")
			&& getWeapon() == WepName
			) { 
		team = getSelfTeam();
		x = GetActorX(0);
		y = GetActorY(0);
		z = GetActorZ(0) + GetActorViewHeight(0);
		angle = GetActorAngle(0);
		pitch = pitchAdjust(GetActorPitch(0));
		
		//targetRegister = -1;
		//angleDistRegister = MAX_TARGET_ANGLE;
		if(!Checkinventory("TargHolder"))
		{
		
		setuservariable(0,"User_STargTID",-1);
		
		if(Checkinventory("TargContractor"))
		{setuservariable(0,"User_angleDistRegister",MAX_TARGET_ANGLE2);}
		else
		{setuservariable(0,"User_angleDistRegister",MAX_TARGET_ANGLE);}
			
			switch(TargType)
				{
				Case 0:
				Case 1:
				if(team!=TEAM_COOP && team != TEAM_NONE) // Can't use Targ Type 0 or 1 in team games
					{
					for(i=0;i<ServerMax;i++)
						{
						if(i!=ownerNumber){TargeterTeam(team, x, y, z, angle, pitch, i, TargType);}
						}
					}
				break;
				default:
				for(i=0;i<ServerMax;i++)
					{
					if(i!=ownerNumber){Targeter(x, y, z, angle, pitch, i);}
					}
				break;
				
				}
		}
		
		if(xyzDistance(0,getuservariable(0,"User_STargTID")+1000) <= TargRange)
			{
			SetInventory("CureTargeter", getuservariable(0,"User_STargTID")+1000);
			}
		else 
			{
			If(CheckInventory("CureTargeter")){TakeInventory("CureTargeter", CheckInventory("CureTargeter"));}
			}
		adjustInventory("TargetingFlag",getuservariable(0,"User_STargTID")+1);
		if (TargRange!=checkinventory("TargetingRangeFlag"))
			{
			setuservariable(0,"User_STargRange",TargRange);
			adjustInventory("TargetingRangeFlag",getuservariable(0,"User_STargRange")+1);
			}
		//giveinventory("TargScriptActive");
		delay(1);
	}
		//takeinventory("TargScriptActive",9)
		setuservariable(0,"User_STargTID",-1);
		setuservariable(0,"User_angleDistRegister",MAX_TARGET_ANGLE);
		adjustInventory("TargetingFlag",0);
		adjustInventory("TargetingRangeFlag",0);
}
 
Script "ReturnCureTargeter" (int PlayerTID)
{
SetResultValue(CheckActorInventory(PlayerTID, "CureTargeter"));
}

function void TargeterTeam(int team, int x, int y, int z, int angle, int pitch, int i, int TargType) {
	if(team != GetPlayerInfo(i, PLAYERINFO_TEAM) && TargType <= 0) 
		{
		Targeter(x, y, z, angle, pitch, i);
		}
		
	else if(team == GetPlayerInfo(i, PLAYERINFO_TEAM) && TargType == 1) 
		{
		Targeter(x, y, z, angle, pitch, i);
		}
		
	Else if(TargType >= 2) 
		{
		Targeter(x, y, z, angle, pitch, i);
		}
}

function void Targeter(int x, int y, int z, int angle, int pitch, int i) {
	int target = i+1000;
	if(CheckActorInventory(target,"Discorded")==0
		&& GetActorProperty(target,APROP_HEALTH)>0
		&& CheckSight(0,target,CSF_NOFAKEFLOORS)) {
		int xDist = GetActorX(target) - x;
		int yDist = GetActorY(target) - y;
		int angleDist = vectorangle(xDist,yDist);
		int dist = fDistanceVal1(angleDist, xDist, yDist);
		int zDist = GetActorZ(target) + PLAYER_CENTER - z;
		int pitchDist = vectorangle(dist, zDist);
		//dist = fDistanceVal2(pitchDist, dist, zDist);		
		
		angleDist = WrapAround(angleDist-angle);
		pitchDist = WrapAround(pitchDist-pitch);
		angleDist = fixedMul(angleDist,angleDist) + fixedMul(pitchDist,pitchDist);
		//print(f:angleDist);
		if(angleDist<getuservariable(0,"User_angleDistRegister")) {
			//targetRegister = i;
			//angleDistRegister = angleDist;
			
			setuservariable(0,"User_STargTID",i);
			setuservariable(0,"User_angleDistRegister",angleDist);
			
			
		}
	}
}

function int fDistanceVal1(int ang, int x, int y)
{
	int len;
	
	if(((ang+0.125)%0.5) > 0.25) len = fixeddiv(y, sin(ang));
	else len = fixeddiv(x, cos(ang));

	//print(f:len);
	return len;
}

function int fDistanceVal2(int ang, int len, int z)
{
	if(((ang+0.125)%0.5) > 0.25) len = fixeddiv(z, sin(ang));
	else len = fixeddiv(len, cos(ang));

	//print(f:len);
	return len;
}

function int pitchAdjust(int i) {
	if(i>0.0) return 1.0-i;
	return -i;
}

function int WrapAround(int i)
{
	if(i<-0.5) return i+1.0;
	if(i>0.5) return i-1.0;
	return i;
}


function int getSelfTeam(void)
{
if (GetCVar("teamplay")==1||GetCVar("teamlms")==1||GetCVar("teampossession")==1
||GetCVar("teamgame")==1){
	Return PlayerTeam();
} else if (GetCVar("cooperative")==1) {
	Return TEAM_COOP;
}
Return TEAM_NONE;
}

function void adjustInventory(str item, int quantity) {
	int diff = quantity-CheckInventory(item);
	if(diff>0) {
		giveInventory(item,diff);
	} else if (diff<0) {
		takeInventory(item,-diff);
	}
}

function void adjustActorInventory(int actor, str item, int quantity) {
	int diff = quantity-CheckActorInventory(actor,item);
	if(diff>0) {
		giveActorInventory(actor,item,diff);
	} else if (diff<0) {
		takeActorInventory(actor,item,-diff);
	}
}

script 405 ENTER CLIENTSIDE {
	int ownerNumber = PlayerNumber();
	
	if(ownerNumber==ConsolePlayerNumber()) {
	
		int xOffset = 10.0;
		int yOffset = 380.0;
		int t;
		int T_Range;
		int i;
	
		while(GetActorProperty(0,APROP_HEALTH) > 0) {
			t =  checkInventory("TargetingFlag"); //getuservariable(0,"User_STargTID")+1;
			T_Range = checkInventory("TargetingRangeFlag"); //getuservariable(ownerNumber+1000,"User_STargRange");
			
			if(t>0) {
			if(checkinventory("TargHolder")) {
				HudMessageOnActorZPlusAllign(1000-1+t, PLAYER_CENTER, 103, 0, 0, 0, 0, T_Range, "JUSTA0", "Target", 0, CR_UNTRANSLATED);
				}
				else
				{
				HudMessageOnActorZPlusAllign(1000-1+t, PLAYER_CENTER, 103, 0, 0, 0, 0, T_Range, "JUSTB0", "Target", 0, CR_UNTRANSLATED);
				}
			}
			
			//apparently these two for loops are done in a way that excludes the
			//script activator. possibly for potential desynch maybe?
			
			for(i=0;i<ownerNumber;i++) {
				if(CheckActorInventory(1000+i,"Discorded")) {
					HudMessageOnActorZPlusAllign(1000+i, PLAYER_CENTER, 200+i, 0, 0, 0, -10, 9000, "JUSTA0", "Discord", 0, CR_UNTRANSLATED);
				}
			}
			for(i=ownerNumber+1;i<ServerMax;i++) {
				if(CheckActorInventory(1000+i,"Discorded")) {
					HudMessageOnActorZPlusAllign(1000+i, PLAYER_CENTER, 200+i, 0, 0, 0, -10, 9000, "JUSTA0", "Discord", 0, CR_UNTRANSLATED);
				}
			}
			
			delay(1);
		}
	}
}

script 406 RESPAWN CLIENTSIDE {
	ACS_ExecuteAlways(405,0);
}

script 409 ENTER { //So joining players see stuff right
	for(int i=0;i<ServerMax;i++) {
		Thing_ChangeTID(1000+i,1000+i);
	}
}
//Pretty sure I don't need a respawn script to call this too.

//HudMessageOnActor from ZDoom wiki
function void HudMessageOnActorZPlusAllign(int tid, int ZPlus, int msgID, int hudX, int hudY, int xOffset, int yOffset, int range, str sprite, str text, int holdTime, str colour)
{
		
	int dist, angle, vang, pitch, x, y;
	
	if (holdTime == 0) { holdTime = 0.1; }	
	if (hudX == 0) { hudX = 640; }
	if (hudY == 0) { hudY = 480; }
	
	if(sprite != -1)
	{
		
		SetFont(sprite);
		text = "A";
		
	}
	
	SetHudSize(hudX, hudY, 1);
	x = GetActorX(tid) - GetActorX(0);
	y = GetActorY(tid) - GetActorY(0);
	
	vang = VectorAngle(x,y);
	angle = (vang - GetActorAngle(0) + 1.0) % 1.0;
	
	if(((vang+0.125)%0.5) > 0.25) dist = FixedDiv(y, sin(vang));
	else dist = FixedDiv(x, cos(vang));
	
	if ((angle < 0.23 || angle > 0.85) && (dist >> 16) < range)
	{
		
		if (GetActorPitch(0) >= -0.5 && GetActorPitch(0) <= 0.5)
		{
 
			pitch = VectorAngle(dist, GetActorZ(tid) + ZPlus - (GetActorZ(0) + GetActorViewHeight(0)));
			pitch += FixedMul(GetActorPitch(0), 1.2) % 1.0;
 
			if ((hudX/2) * sin(angle) != 0 && cos(angle) != 0 && (hudX/2) * sin(pitch) != 0 && cos(pitch) != 0)
			{
				
				x = hudX/2 - ((hudX/2) * sin(angle) / cos(angle));
				y = hudY/2 - ((HUDX/2) * sin(pitch) / cos(pitch));
				
				x+=xOffset;
				y+=yOffset;
				
				HudMessage(s:text; HUDMSG_PLAIN, msgID, colour, (x << 16)+0.1, (y << 16)+0.1, holdTime);
				
			}
			
		}
		
	}
	
}



script "CSACS_AbraGroupTeleport" (int Range)
{
if(ACS_ExecuteWithResult(975,1)==1)
	{
	for(int i = 0; i<GetMaxPlayers(); i++)
		{
		if(PlayerInGame(i) && GetActorProperty(0,APROP_Health)>0 && i!=ActivatorTID()-1000)
			{
			if(GetPlayerInfo(ActivatorTID()-1000, PLAYERINFO_TEAM)==GetPlayerInfo(i, PLAYERINFO_TEAM))
				{
				if(xyzDistance(ActivatorTID(),i+1000)<=Range && CheckSight(ActivatorTID(),i+1000,0))
					{
					Thing_Move(i+1000,ActivatorTID()+5000,1);
					}
				}
			}
		}
	}
Delay(1);
Thing_Move(ActivatorTID(),ActivatorTID()+5000,1);
}

function void hudmessageonactor(int tid, int msgID, int hudX, int hudY, int xOffset, int yOffset, int range, str sprite, str text, int holdTime, str colour, int swap)
{
	int dist, angle, vang, pitch, x, y;

	if (hudX == 0) { hudX = 640; }
	if (hudY == 0) { hudY = 480; }

	if(sprite != -1)
	{
		SetFont(sprite);
		text = "A";
		//offset = 0.1;
	}

	SetHudSize(hudX, hudY, 1);
	x = GetActorX(tid) - GetActorX(0);
	y = GetActorY(tid) - GetActorY(0);

	vang = VectorAngle(x,y);
	angle = (vang - GetActorAngle(0) + 1.0) % 1.0;

	if(((vang+0.125)%0.5) > 0.25) dist = FixedDiv(y, sin(vang));
	else dist = FixedDiv(x, cos(vang));

	if ((angle < 0.2 || angle > 0.8) && (dist >> 16) < range)
	{
		if (GetActorPitch(0) >= -0.25 && GetActorPitch(0) <= 0.25)
		{
			pitch = VectorAngle(dist, GetActorZ(tid) - (GetActorZ(0) + 41.0));
			pitch = (pitch + GetActorPitch(0) + 1.0) % 1.0;
			if ((hudX/2) * sin(angle) != 0 && cos(angle) != 0 && (hudX/2) * sin(pitch) != 0 && cos(pitch) != 0) //    Fixes divide by zero
			{
				x = hudX/2 - ((hudX/2) * sin(angle) / cos(angle));
				y = hudY/2 - ((HUDX/2) * sin(pitch) / cos(pitch));

				x+=xOffset;
				y+=yOffset;
				if(swap){HudMessage(i:dist >> 16; HUDMSG_PLAIN, msgID, colour, (x << 16), (y << 16), holdTime);}
				else{HudMessage(s:text; HUDMSG_PLAIN, msgID, colour, (x << 16), (y << 16), holdTime);}
			}
		}
	}
}


script "CSCC_TEAMIDENT" (void)
//Tiny script that returns team number, used for sticky bombs

//Possibly redundant but could be handy ~Bika
{
If(PlayerTeam()==0){SetResultValue(1);}
If(PlayerTeam()==1){SetResultValue(2);}
If(PlayerTeam()==2){SetResultValue(3);}
If(PlayerTeam()==3){SetResultValue(4);}
}


#DEFINE BASEBLASTMIN 120
Script "BlastKnockback" (int BlastThrust, int ThrustForceH, int MaxRadius)
{

int userTID;
int userTeam;
Bool SelfThrustOnly = False;
int ThrustForce = BlastThrust;
	if(ThrustForce < 0) {SelfThrustOnly = true; ThrustForce = ThrustForce*-1;}
int AdditiveForce;
	if(MaxRadius < 0) {AdditiveForce = 1; MaxRadius = MaxRadius*-1;}

	if(ActivatorTID() == 0)
	{
		userTID = ACS_ExecuteWithResult(257, 0);
		userTeam = GetPlayerInfo(userTID - 1000, PLAYERINFO_TEAM);
	}
	else
	{
		userTID = ActivatorTID();
	}
	

int ActX = GetActorX(0);
int ActY = GetActorY(0);
//int ActHeight = GetActorProperty(0,APROP_HEIGHT) >>16;
int Dist;
int distdiff;
int ZThrust;
int XYThrust;
int targetTID;
int PlayerX;
int PlayerY;
int pitch;

int FinalForce;
int FinalForceH;

//int ThrustDrop = NoNeg( (Dist/10) - MaxRadius) << 16;
//SetActivatorToTarget(0);

For(int q = 0;q < ServerMax; q++)
	{
		targetTID = q+1000;
		
		if(!PlayerInGame(q))
		{
			continue;
		}
		
		if( (userTID != targetTID) && (SelfThrustOnly == True)){continue;}
		if(ACS_ExecuteWithResult(975, 1) == 1)
		{
			if(userTeam == GetPlayerInfo(q, PLAYERINFO_TEAM) && userTID != targetTID)
			{
				continue;
			}
		}
		
		//if()
		
		//log(s:"distance is ",i:xyzDistance(0, targetTID));
		if(xyzDistance(0, targetTID) < MaxRadius && checksight(0,targetTID,0) == True
		|| xyzDistance(0, targetTID) <20)
		{
		 Dist = xyzDistance(0,targetTID);
	
		 distdiff = NoNeg(Dist - MaxRadius);
		 pitch = GetTargetPitch(targetTID,0);
		 //VectorAngle(xyDistance(0, targetTID), GetActorZ(0) - GetActorZ(targetTID) >> 16);
		 //log(s:"pitch relative to player ",i:q,s:" is ", f:pitch);
		 //log(s:"Height is  ",i:ActHeight);
		 if(xyzDistance(0, targetTID) > BASEBLASTMIN)
		 {
		 FinalForce = ceil(FixedMul(ThrustForce << 16, 1.0 - FixedDiv(Dist, MaxRadius)));
		 FinalForceH = ceil(FixedMul(ThrustForceH << 16, 1.0 - FixedDiv(Dist, MaxRadius)));
		 }
		 Else
		 {
		 FinalForce = ThrustForce;
		 FinalForceH = ThrustForceH;
		 }
		 ZThrust = (sin(pitch)*-FinalForce); //GetActorPitch(targetTID)
		 XYThrust = (cos(pitch)*-FinalForceH);
		 
		 if (GetActorZ(targetTID) - GetActorFloorZ (targetTID) == 0){XYThrust = FixedMul(XYThrust,1.0);}
		 //log(i:GetActorZ(targetTID) - GetActorFloorZ (targetTID));
		 //log(s:"horizontal thrust is is  ",i:(FixedMul(XYThrust , 1.0 - fixedDiv(distdiff,100)))>> 16);
		 PlayerX = GetActorX(targetTID);
		 PlayerY = GetActorY(targetTID);
		 
		ThrustThing(VectorAngle(ActX - PlayerX,ActY - PlayerY)>>8,(FixedMul(XYThrust , 1.0 - fixedDiv(distdiff,100)))>> 16,1,targetTID);
		thrustthingz(targetTID,(FixedMul(ZThrust , 1.0 - fixedDiv(distdiff,100)))>> 16,1,AdditiveForce);
	}
}

}


//returns the relative pitch of a thing with tid2, from a thing with tid1.
function int GetTargetPitch (int tid1, int tid2)
{
    int x, y, z, xy, a;
    x = GetActorX(tid2) - GetActorX(tid1);
    y = GetActorY(tid2) - GetActorY(tid1);
    z = GetActorZ(tid2) - GetActorZ(tid1);
    a = VectorAngle(x, y);

    if ((a + 0.125) % 0.5 > 0.25)
        xy = FixedDiv(y, sin(a));
    else
        xy = FixedDiv(x, cos(a));

    return -VectorAngle(xy, z);
}

str user_variables[3] =
{
"user_wepangle",
"user_weppitch",
"user_wepangle2",
};

script "GRAB_MEMANGLE" (int num, int Swap)
{
	Switch(Swap)
	{
		Case 1:
		SetResultValue(GetUserVariable(0,user_variables[num])>>16);
		break;
		Default:
		Case 0:
		SetResultValue(GetUserVariable(0,user_variables[num]));
		break;
	}
}

Script "SHIFT_MEMANGLE" (int currentAngle, int inputAngle, int angleChangeLimit)
{
//print(i:inputAngle);

int angleDif = inputAngle-currentAngle;
//print(i:angleDif);

int returnAngle;

if (angleDif>180) {
	if ((angleDif-360)<-angleChangeLimit) {
		returnAngle = currentAngle-angleChangeLimit;
		if (returnAngle<0) returnAngle+=360;
    } else {
		returnAngle = inputAngle;
	}
} else if (angleDif<-180) {
	if ((angleDif+360)>angleChangeLimit) {
		returnAngle = currentAngle+angleChangeLimit;
		if (returnAngle>=360) returnAngle-=360;
    } else {
		returnAngle = inputAngle;
	}
} else if (angleDif<-angleChangeLimit) {
	returnAngle = currentAngle-angleChangeLimit;
	if (returnAngle<0) returnAngle+=360;
} else if (angleDif>angleChangeLimit) {
	returnAngle = currentAngle+angleChangeLimit;
	if (returnAngle>=360) returnAngle-=360;
} else {
	returnAngle = inputAngle;
}

//print(i:currentAngle);

setResultValue(returnAngle);
}

Script "CSCC_ScriptCharge" (int set)
{
/*
General Purpose Script used to return a value from the inventory item "ScriptCharge"
*/
setResultValue(CheckInventory("ScriptCharge"));
}

Script "CSCC_ClassItemToggle" (int ToggleValue)
{
/*
Script designed for all classes that aim to use an inventory to toggle between modes, 
*/

if (ToggleValue <= 0){TakeInventory("ClassToggleItem",999); Terminate;}

if(CheckInventory("ClassToggleItem") != ToggleValue)
	{
		Until(CheckInventory("ClassToggleItem") == ToggleValue)
		{
		TakeInventory("ClassToggleItem",999);
		GiveInventory("ClassToggleItem",ToggleValue);
		}

	}
}


script "MCSpeedSetScript" (int speed)
{
	switch (speed) {
	//Devion Glide
		case 1:
		  SetActorProperty(0,APROP_SPEED,1.25);
		  break;
		case 0:
		  SetActorProperty(0,APROP_SPEED,1.0);
		  break;
		default:
		  SetActorProperty(0,APROP_SPEED,1.0);
		  break;
	}
}

#DEFINE SPELLNUM 10

str RmSpellsList[spellnum]={
	"Diara",
	"Fira",
	"Aerora",
	"Blizzara",
	"Slow",
	"Watera",
	"Thundara",
	"Blink",
	"Temper",
	"Focus"
	};
	
	str RMSpellMem[4];
	//This array here will keep track of the last 4 spells gained, thus when a new one
	//is given, it checks to see if it is listed on here first before handing the spell
	
	function void AppendSpell (str spellname)
	// this function adds the new spell to the list and pushes the other entries down
	{
	 RMSpellMem[3] =  RMSpellMem[2];
	 RMSpellMem[2] =  RMSpellMem[1];
	 RMSpellMem[1] =  RMSpellMem[0];
	 RMSpellMem[0] = spellname;
	}
	
	function int spellchecker (str spellname)
	{
	int matchCount;
	//this checks for any matches of a spell in question within the spellmemory, if we
	//have a match or more, then this spell cannot be given.
		for(int i=0; i<4; i++)
		{if(RMSpellMem[i] == spellname){++matchCount;}} 
		return matchCount;
	}

script "RedMageSpellHandler" (void)
{
int spellcount;
//first, we will start by taking out all existing spells except Diara, since 
//Diara is in element 0, a for loop that starts at 1 will do the trick
	for(int i=1; i<spellnum; i++) 
	{
	Takeinventory(StrParam(s:"RedMage",s:RmSpellsList[i],s:"Wep"),99);
	Takeinventory(StrParam(s:RmSpellsList[i],s:"SpellFlag"),99);
	}
	
//now time to give some spells, 
	until(spellcount >= 2)
	{
	//untill we have given two spells, keep looping. so here we will pick a random number and check for any matches in
	//spellmemory, if we do have a match then we just loop again. if we don't, we will give that spell and then increment
	// the spellcount variable. when it reaches 2, the loop stops.
	int randspell = random(1,spellnum - 1);
	int spellmatch = spellchecker(RmSpellsList[randspell]);
		if(spellmatch == 0)
		{
		giveinventory(StrParam(s:"RedMage",s:RmSpellsList[randspell],s:"Wep"),1);
		giveinventory(StrParam(s:RmSpellsList[randspell],s:"SpellFlag"),1);
		AppendSpell(RmSpellsList[randspell]);
		spellcount = ++spellcount;
		
		}
	}
}

script "CBMTeamColor" (int ID, int Swap) //CBM's team color script, 1-4 used in respective order of teams. Refer to Red Mage's Subzero Field/Ice Cloak for examples.
{
if(Swap==1){
	if(ClassifyActor(ID) & ACTOR_PLAYER){
		if(GetCVar("teamlms")==1||GetCVar("ctf")==1||GetCVar("teamplay")==1||GetCVar("oneflagctf")==1||GetCVar("teampossession")==1||GetCVar("teamgame")==1 ){
			SetResultValue(GetPlayerInfo(ID-1000,PLAYERINFO_TEAM));
			terminate;
		}
	}
SetResultValue(-1); //TEAM_NONE is the equivalent, which is the fallback when there is no team.
}


if(!(ClassifyActor(ActivatorTID()) & ACTOR_PLAYER)) {
SetActivatorToTarget(0);
}
if(ClassifyActor(ActivatorTID()) & ACTOR_PLAYER) {
if(GetCVar("teamlms")==1||GetCVar("ctf")==1||GetCVar("teamplay")==1||GetCVar("oneflagctf")==1||GetCVar("teampossession")==1||GetCVar("teamgame")==1 ){SetResultValue(PlayerTeam());terminate;}
}
SetResultValue(-1);
}

Script "FusionPrintScript" (void)
{
while(CheckInventory("IsDead")==0)
	{
	if(PlayerInGame(PlayerNumber()) && CheckInventory("IsRedMage"))
		{
		if(CheckInventory("FiraSpellFlag") && CheckInventory("ThundaraSpellFlag")){
			SetFont("FUSICN27");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("FiraSpellFlag") && CheckInventory("WateraSpellFlag")){
			SetFont("FUSICN23");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("FiraSpellFlag") && CheckInventory("BlinkSpellFlag")){
			SetFont("FUSICN21");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("FiraSpellFlag") && CheckInventory("TemperSpellFlag")){
			SetFont("FUSICN5");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("AeroraSpellFlag") && CheckInventory("ThundaraSpellFlag")){
			SetFont("FUSICN2");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("AeroraSpellFlag") && CheckInventory("FocusSpellFlag")){
			SetFont("FUSICN22");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("BlizzaraSpellFlag") && CheckInventory("ThundaraSpellFlag")){
			SetFont("FUSICN15");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("BlizzaraSpellFlag") && CheckInventory("FocusSpellFlag")){
			SetFont("FUSICN25");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("SlowSpellFlag") && CheckInventory("ThundaraSpellFlag")){
			SetFont("FUSICN4");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("SlowSpellFlag") && CheckInventory("FocusSpellFlag")){
			SetFont("FUSICN37");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("WateraSpellFlag") && CheckInventory("ThundaraSpellFlag")){
			SetFont("FUSICN14");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("WateraSpellFlag") && CheckInventory("TemperSpellFlag")){
			SetFont("FUSICN6");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("ThundaraSpellFlag") && CheckInventory("FocusSpellFlag")){
			SetFont("FUSICN33");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("BlinkSpellFlag") && CheckInventory("TemperSpellFlag")){
			SetFont("FUSICN18");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("TemperSpellFlag") && CheckInventory("FocusSpellFlag")){
			SetFont("FUSICN9");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("AeroraSpellFlag") && CheckInventory("BlinkSpellFlag")){
			SetFont("FUSICN28");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("ThundaraSpellFlag") && CheckInventory("BlinkSpellFlag")){
			SetFont("FUSICN29");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("FiraSpellFlag") && CheckInventory("SlowSpellFlag")){
			SetFont("FUSICN11");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("FiraSpellFlag") && CheckInventory("AeroraSpellFlag")){
			SetFont("FUSICN16");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("FiraSpellFlag") && CheckInventory("BlizzaraSpellFlag")){
			SetFont("FUSICN32");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("AeroraSpellFlag") && CheckInventory("TemperSpellFlag")){
			SetFont("FUSICN8");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("AeroraSpellFlag") && CheckInventory("WateraSpellFlag")){
			SetFont("FUSICN3");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("FocusSpellFlag") && CheckInventory("WateraSpellFlag")){
			SetFont("FUSICN17");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("FocusSpellFlag") && CheckInventory("FiraSpellFlag")){
			SetFont("FUSICN12");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("BlizzaraSpellFlag") && CheckInventory("TemperSpellFlag")){
			SetFont("FUSICN10");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("ThundaraSpellFlag") && CheckInventory("TemperSpellFlag")){
			SetFont("FUSICN7");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("SlowSpellFlag") && CheckInventory("BlinkSpellFlag")){
			SetFont("FUSICN34");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("SlowSpellFlag") && CheckInventory("BlizzaraSpellFlag")){
			SetFont("FUSICN20");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("SlowSpellFlag") && CheckInventory("WateraSpellFlag")){
			SetFont("FUSICN19");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("AeroraSpellFlag") && CheckInventory("BlizzaraSpellFlag")){
			SetFont("FUSICN26");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("WateraSpellFlag") && CheckInventory("BlinkSpellFlag")){
			SetFont("FUSICN30");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("BlinkSpellFlag") && CheckInventory("FocusSpellFlag")){
			SetFont("FUSICN1");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("BlinkSpellFlag") && CheckInventory("BlizzaraSpellFlag")){
			SetFont("FUSICN31");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("BlizzaraSpellFlag") && CheckInventory("WateraSpellFlag")){
			SetFont("FUSICN24");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("AeroraSpellFlag") && CheckInventory("SlowSpellFlag")){
			SetFont("FUSICN35");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);}
		else if(CheckInventory("SlowSpellFlag") && CheckInventory("TemperSpellFlag")){
			SetFont("FUSICN36");
			HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);
			}
	else{
		SetFont("FUSICN38"); //If you ever see this in-game without any indication of new fusions tell Zomo immediately.
		HudMessage(s:"A"; HUDMSG_FADEOUT, 75, CR_BLACK,0.02, 0.45, 0.75,0.5);
		}
	Delay(7);
	restart;}
	}
}


//734
Script "SubZeroFieldHandler" (VOID)
{
int SZField = 0;
	If(xyzDistance(0,125) > 400) // && FiringPlayer!=Target_TID
		{
		SZField = 1;
		}
	SetResultValue(SZField);
}

//735
Script "RedMageSprintHandler" (Int WhichCase, Int SprintTID, Int RenderTID) //Simple TID assignment for Lightning Sprint and Space Render
{
Switch(WhichCase)
	{
	Case 0: //Lightning Sprint
		{
		SetActivatorToTarget(0);
		Int LSprintTID = (SprintTID + 2000);
		//Print(d:LSprintTID);
		SetResultValue(LSprintTID);
		}
	Case 1: //Space Render
		{
		SetActivatorToTarget(0);
		Int SRenderTID = (RenderTID + 2000);
		//Print(d:SpaceRenderTID);
		SetResultValue(SRenderTID);
		}
	}
}

script "CSACS_DavColorChange" (void)
{
CreateTranslation (3191, 192:192=196:196, 198:198=205:205);
CreateTranslation (3192, 192:192=170:170, 198:198=171:171);
CreateTranslation (3193, 192:192=138:138, 198:198=104:104);
CreateTranslation (3194, 192:192=214:214, 198:198=229:229);
/*
if(CheckInventory("WilyTeamFlag")){
	print(s:"You're on the wily team!");
	Thing_SetTranslation(0, 3192);
}else if(CheckInventory("KingTeamFlag")){
	Thing_SetTranslation(0, 3193);
}else if(CheckInventory("CossackTeamFlag")){
	Thing_SetTranslation(0, 3194);
}else{
	Thing_SetTranslation(0, 3191);
*/	
	
	Switch(PlayerTeam())
			{
			Case 0:
				Thing_SetTranslation(0, 3191);
				break;
			Case 1:
				Thing_SetTranslation(0, 3192);
				break;
			Case 2:
				Thing_SetTranslation(0, 3193);
				break;
			Case 3:
				Thing_SetTranslation(0, 3194);
				break;
			default:
				Thing_SetTranslation(0, 3191);
				break;
				
			}
}

script "CSACS_GravItem" (void)
{
int GravVel = GetActorVelZ(0) >> 16;
if(GravVel <= 0){GravVel *= -1;}
SetInventory("GravitronVelocity",GravVel);
}

Script "CSACS_GeeHealth" (int StarterDelay, int Rate)
{   
int HP;
while(GetActorProperty(0,APROP_Health)>0 && PlayerInGame(PlayerNumber()) && (CheckInventory("GeeBurstBoss1")||CheckInventory("GeeBurstBoss2")))
	{
	while(GetActorProperty(0,APROP_Health)<GetActorProperty(0,APROP_SpawnHealth))
		{
		if(GetActorProperty(0,APROP_Health)<=0 || !PlayerInGame(PlayerNumber()) || !(CheckInventory("GeeBurstBoss1")||CheckInventory("GeeBurstBoss2"))){terminate;}
		if(CheckInventory("GeeRegen")>=StarterDelay)
			{
			ACS_NamedExecuteAlways("CSACS_Basic(Over)Heal",0,0,1);
			HP = GetActorProperty(0,APROP_Health);
			Delay(Rate);
			}
		else
			{
			GiveInventory("GeeRegen",1); 
			Delay(1);
			}
		if(HP>GetActorProperty(0,APROP_Health)){TakeInventory("GeeRegen",999);}
		HP = GetActorProperty(0,APROP_Health);
		}
	TakeInventory("GeeRegen",999);
	Delay(1);
	}
}

script "CSACS_PistonStaleWatcher" (int PistonTimer)
{
int Counter = 0;
while(Counter<PistonTimer)
	{
	Delay(1);
	Counter++;
	if(CheckInventory("PistonStaleReset")){Counter = 0;}
	}
TakeInventory("PistonStale",999);
}

script "CSACS_CFlashCheck" (void)
{
int Result = 0;
SetActivatorToTarget(0);
if(CheckActorClass(0,"MegamanC")&&CheckWeapon("CentaurFlashWepCS")&&GetActorProperty(0,APROP_Alpha)<1.0){Result = 1;}
if(CheckActorClass(0,"CopyRobot")&&CheckWeapon("CentaurFlashWepCS")&&GetActorProperty(0,APROP_Alpha)<1.0){Result = 2;}
SetResultValue(Result);
}

// Script called by Healmore's protect 
Script "ProtectS_Warper" (void) CLIENTSIDE
{
	int Player = ACS_NamedExecuteWithResult("core_gettarget",0);
	
	// Loop if shield is active
	while(GetActorProperty(Player, APROP_HEALTH)>0
	&& CheckActorInventory(Player, "ProtectS_Power") > 0
	){
		Delay(1);
	}
	
	// Remove
	Thing_Remove(0);
	GiveActorInventory(Player, "ProtectS_ShedEffect",1);
}
//----|Rozark
Script "RozarkHomingCheck" (void)
{
int MaxPlayers = GetMaxPlayers(); //MarkOfTheRabbit
int ShooterPLN = ACS_ExecuteWithResult(257, 1);
int KnockBack = CheckInventory("YangKnockBackFlag");
int MaxDistance = 9000;
int Dist;
int Marked = -1;
For(int i = 0; i < MaxPlayers; i++)
	{
	If(PlayerInGame(i) && i!=ShooterPLN)
		{
		If(CheckActorInventory(i+1000, "MarkOfTheRabbit") && !CSACS_SameTeamCheck(ShooterPLN, i))
			{
			dist = XYZDistance(ShooterPLN+1000, i+1000);
			If(dist < MaxDistance)
				{
				MaxDistance = dist;
				Marked = i+1000;
				}
			}
		}
	}
If(Marked > 0){SetPointer(AAPTR_TRACER, Marked);}
}
